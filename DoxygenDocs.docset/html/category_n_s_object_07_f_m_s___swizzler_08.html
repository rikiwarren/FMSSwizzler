<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FMSSwizzler: NSObject(FMS_Swizzler) Category Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FMSSwizzler
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="category_n_s_object_07_f_m_s___swizzler_08-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NSObject(FMS_Swizzler) Category Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>FMSSwizzler's public methods.  
 <a href="category_n_s_object_07_f_m_s___swizzler_08.html#details">More...</a></p>

<p><code>#import &lt;<a class="el" href="_n_s_object_09_f_m_s_swizzler_8h_source.html">NSObject+FMSSwizzler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad66725b3dc5baf8c59142e2647cf4f37"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_n_s_object_07_f_m_s___swizzler_08.html#ad66725b3dc5baf8c59142e2647cf4f37">FMS_dynamiclySubclass</a></td></tr>
<tr class="memdesc:ad66725b3dc5baf8c59142e2647cf4f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the instance a subclass of its current class. This lets you override methods on the new subclass without affecting any other objects in your project.  <a href="#ad66725b3dc5baf8c59142e2647cf4f37"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3b21e8a4c6a7668de51f77ba308cc4fe"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_object_07_f_m_s___swizzler_08.html#a3b21e8a4c6a7668de51f77ba308cc4fe">FMS_aliasInstanceMethod:newSelector:</a></td></tr>
<tr class="memdesc:a3b21e8a4c6a7668de51f77ba308cc4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a new instance method using the same implementation as the original selector  <a href="#a3b21e8a4c6a7668de51f77ba308cc4fe"></a><br/></td></tr>
<tr class="memitem:ac4c9e082d74e163f82d2cd429f735a89"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_object_07_f_m_s___swizzler_08.html#ac4c9e082d74e163f82d2cd429f735a89">FMS_replaceInstanceMethod:withImplementationBlock:</a></td></tr>
<tr class="memdesc:ac4c9e082d74e163f82d2cd429f735a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the specified method with the given block.  <a href="#ac4c9e082d74e163f82d2cd429f735a89"></a><br/></td></tr>
<tr class="memitem:a7acd4f5c709742f78301d791530fc698"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_object_07_f_m_s___swizzler_08.html#a7acd4f5c709742f78301d791530fc698">FMS_overrideInstanceMethod:oldSelector:implementationBlock:</a></td></tr>
<tr class="memdesc:a7acd4f5c709742f78301d791530fc698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to replace the implementation of an existing method, while still providing access to the original implementation.  <a href="#a7acd4f5c709742f78301d791530fc698"></a><br/></td></tr>
<tr class="memitem:a8abadede831b1fabdf944cf802c19011"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_object_07_f_m_s___swizzler_08.html#a8abadede831b1fabdf944cf802c19011">FMS_aliasClassMethod:newSelector:</a></td></tr>
<tr class="memdesc:a8abadede831b1fabdf944cf802c19011"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a new class method using the same implementation as the original selector  <a href="#a8abadede831b1fabdf944cf802c19011"></a><br/></td></tr>
<tr class="memitem:ada43393ead6d6976de66fd0df1211e3d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_object_07_f_m_s___swizzler_08.html#ada43393ead6d6976de66fd0df1211e3d">FMS_replaceClassMethod:withImplementationBlock:</a></td></tr>
<tr class="memdesc:ada43393ead6d6976de66fd0df1211e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the specified class method with the given block.  <a href="#ada43393ead6d6976de66fd0df1211e3d"></a><br/></td></tr>
<tr class="memitem:af89360df900835e962975d2c7b32f06f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_object_07_f_m_s___swizzler_08.html#af89360df900835e962975d2c7b32f06f">FMS_overrideClassMethod:oldSelector:implementationBlock:</a></td></tr>
<tr class="memdesc:af89360df900835e962975d2c7b32f06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to replace the implementation of an existing class method, while still providing access to the original implementation.  <a href="#af89360df900835e962975d2c7b32f06f"></a><br/></td></tr>
<tr class="memitem:ab9e309f9b20d03131be614a852347eb8"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="_n_s_object_09_f_m_s_swizzler_8h.html#ae568c6e4323fed2a329c8e59a7f15a95">FMSPseudoPropertyAdder</a>)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="category_n_s_object_07_f_m_s___swizzler_08.html#ab9e309f9b20d03131be614a852347eb8">FMS_generatePseudoPropertyAdderForType:</a></td></tr>
<tr class="memdesc:ab9e309f9b20d03131be614a852347eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a <code>FMSPseudoPropertyAdder</code> block for the specified class and property type.  <a href="#ab9e309f9b20d03131be614a852347eb8"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>FMSSwizzler's public methods. </p>
<p>Public methods added to the NSObject (and it's decendents) to simplify method and class swizzling, as well as providing support for dynamically adding pseudo properties at runtime. </p>
</div><h2>Member Function Documentation</h2>
<a class="anchor" id="a8abadede831b1fabdf944cf802c19011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) FMS_aliasClassMethod: </td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>originalSelector</em></td>
        </tr>
        <tr>
          <td class="paramkey">newSelector:</td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>newSelector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a new class method using the same implementation as the original selector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalSelector</td><td>This is the original selector whose implementation we wish to alias. This must be a class method that is currently defined either by the current class or by one of its ancestors.</td></tr>
    <tr><td class="paramname">newSelector</td><td>This is the selector for the new class method we will create. This method must not yet exist either in the current class or in any of its ancestors. Additionally, this must have the same number of arguments as <code>originalSelector</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This method creates a new class method using the <code>newSelector</code> and the implementation from the <code>originalSelector</code>. We then have two methods that both use the same implementation. This is particularly useful if you wish to replace an existing method, but still want to be able to access it in your code.</p>
<p>Note: There may be a few odd edge cases where methods check the _cmd hidden before determining their behavior. In these cases, the aliased methods will use the new selector for their _cmd value. So, they may no longer function properly. This should be rare, however. </p>

</div>
</div>
<a class="anchor" id="a3b21e8a4c6a7668de51f77ba308cc4fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) FMS_aliasInstanceMethod: </td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>originalSelector</em></td>
        </tr>
        <tr>
          <td class="paramkey">newSelector:</td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>newSelector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a new instance method using the same implementation as the original selector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalSelector</td><td>This is the original selector whose implementation we wish to alias. This must be an instance method that is currently defined either by the current class or by one of its ancestors.</td></tr>
    <tr><td class="paramname">newSelector</td><td>This is the selector for the new method we will create. This instance method must not yet exist either in the current class or in any of its ancestors. Additionally, this must have the same number of arguments as <code>originalSelector</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This method creates a new method using the <code>newSelector</code> and the implementation from the <code>originalSelector</code>. We then have two methods that both use the same implementation. This is particularly useful if you wish to replace an existing method, but still want access to it.</p>
<p>Note: You must take care when aliasing methods from class clusters. Classes like NSString, NSArray or NSDate declare a public, abstract class&ndash;but then provide private subclasses when instantiated. If you alias the abstract class (e.g. <code>[NSString FMS_aliasInstanceMethod:...</code>) your new method will point to the version of the method defined in the abstract class, not the version provided in the concrete subclass. To correctly alias the subclass, you must call <code>FMS_aliasInstanceMethod</code> on the subclass itself (e.g. `[[myString class] FMS_aliasInstanceMethod...). To make things even more difficult, different instances from the same class cluster may have different concrete subclasses. Bottom line, it's probably best to avoid aliasing methods on class clusters. Alternatively, dynamically subclass the instance before creating the alias to limit the change to just that instance.</p>
<p>Note: Aliasing can also interfere with KVO (though, in potentially useful ways). If you are observing a keypath that corresponds to an accessor method, and you alias that accessor method, then calling the original method will still generate KVO notifications&ndash;but calling the alias will not. This, potentially, lets you sidestep around KVO notification when done deliberately, but can also cause odd bugs when you are not paying attention.</p>
<p>Note: There may be a few odd edge cases where methods check the _cmd hidden before determining their behavior. In these cases, the aliased methods will use the new selector for their _cmd value. So, they may no longer function properly. This should be rare, however. </p>

</div>
</div>
<a class="anchor" id="ad66725b3dc5baf8c59142e2647cf4f37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) FMS_dynamiclySubclass </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the instance a subclass of its current class. This lets you override methods on the new subclass without affecting any other objects in your project. </p>
<p>Calling this method dynamically creates a subclass of the object's current class, then changes the object's class to the newly created subclass. This lets us sandbox any changes we make to the class. It is most often paired with calls to <code>FMS_overrideInstanceMethod:oldSelector:implementationBlock:</code>, letting us override the instances method without modifying any other instances of the class.</p>
<p>Dynamic subclassing avoids many of the problems associated with class clusters.</p>
<p>Note: Any further FMSSwizzling methods must be called on the new class. For example, if I dynamically subclass my <code>self.person</code> instance, I can then override its methods by calling <code>[[self.person class] FMS_overrideInstanceMethod...</code>.</p>
<p>Note: Care must be taken when mixing dynamic subclassing and KVO. KVO uses a version of dynamic subclassing to provide its notifications. Importantly, KVO notifications will only work if the KVO subclass is the last one. Therefore, calling <code>FMS_dynamiclySubclass</code> before calling <code>addObserver:forKeyPath:options:context:</code> works fine. Calling <code>addObserver:forKeyPath:options:context:</code> and then calling <code>FMS_dynamiclySubclass</code> will prevent the notifications from being sent.</p>
<p>Note: Dynamic subclassing cannot be used with tagged pointers. Some NSNumber and NSDate (and possibly other) objects use pointer tagging to improve efficiency. <code>FMS_dynamiclySubclass</code> will check the object's class before trying to dynamically subclass the class. If it finds a tagged pointer (any pointer with a 1 in the lowest bit), it throws an exception. </p>

</div>
</div>
<a class="anchor" id="ab9e309f9b20d03131be614a852347eb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="_n_s_object_09_f_m_s_swizzler_8h.html#ae568c6e4323fed2a329c8e59a7f15a95">FMSPseudoPropertyAdder</a>) FMS_generatePseudoPropertyAdderForType: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_n_s_object_09_f_m_s_swizzler_8h.html#a105a30990436a0245ace5499526862cf">FMSPseudoPropertyType</a>)&#160;</td>
          <td class="paramname"><em>type</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a <code>FMSPseudoPropertyAdder</code> block for the specified class and property type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>A <code>FMSPseudoPropertyType</code> indicating the type of properties the returned adder should create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>FMSPseudoPropertyAdder</code> for the calling class that creates pseudo properties of the type specified in the <code>type</code> parameter.</dd></dl>
<p>This method generates a block that can be used to create pseudo properties. Simply call the block and pass in a single <code>NSString</code> argument. The adder will dynamically create getter and setter methods using the string as the property name. The adder will use <code>objc_getAssociatedObject()</code> and <code>objc_setAssociatedObject()</code> as the data storage for the property. </p>

</div>
</div>
<a class="anchor" id="af89360df900835e962975d2c7b32f06f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) FMS_overrideClassMethod: </td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>selector</em></td>
        </tr>
        <tr>
          <td class="paramkey">oldSelector:</td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>oldSelector</em></td>
        </tr>
        <tr>
          <td class="paramkey">implementationBlock:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows you to replace the implementation of an existing class method, while still providing access to the original implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>This is the selector for the class method you wish to override. </td></tr>
    <tr><td class="paramname">oldSelector</td><td>This is the selector that will be used for accessing the old implementation. This must have the same number of arguments as the original <code>selector</code>. </td></tr>
    <tr><td class="paramname">block</td><td>A block containing our new implementation. This block must start with an argument for the current object (the equivilant of the <code>self</code> argument&ndash;note that we do not need to include the <code>_cmd</code> argument). Next, we need to match all the method's arguments exactly. If you do not, it could cause the applicaiton to crash at runtime. Finally, the block needs to return the same type of data as the original method.</td></tr>
  </table>
  </dd>
</dl>
<p>This method starts by creating an alias of the specified class method using the <code>oldSelector</code> argument. Then it replaces the method's current <code>IMP</code> with a new <code>IMP</code> created from the provided block. This leaves us with two, unique methods: <code>selector</code> points to our new implementation while <code>oldSelector</code> points to the old.</p>
<p>Our implementation block must return the same data type as the original implementation. It must also take a number of arguments equal to the original + 1 (for <code>_self</code>).</p>
<p>Example: Method with 3 arguments: <code>[[Person class] FMS_overrideClassMethod:@selector(personWithFirstName:lastName:age:) oldSelector:@selector(oldPersonWithFirstName:lastName:age:) implementationBlock:^(id _self, NSString *firstName, NSString *lastName, NSUInteger age){return [_self oldPersonWithFirstName:[firstName lowercaseString] lastName:[lastName lowercaseString] age:age;}];</code></p>
<p>Note: replacing a method that the class relies on internally may cause unexpected results. Strongly consider using `FMS_OverrideInsanceMethod:oldSelector:implementationBlock: and calling the original method either before or after your modified code.</p>
<p>Note: There may be a few odd edge cases where the original method checks the _cmd hidden before determining its behavior. In these cases, the old implementation will use <code>oldSelector</code> for their _cmd value. So, they may no longer function properly. This should be rare, however. </p>

</div>
</div>
<a class="anchor" id="a7acd4f5c709742f78301d791530fc698"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) FMS_overrideInstanceMethod: </td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>selector</em></td>
        </tr>
        <tr>
          <td class="paramkey">oldSelector:</td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>oldSelector</em></td>
        </tr>
        <tr>
          <td class="paramkey">implementationBlock:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows you to replace the implementation of an existing method, while still providing access to the original implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>This is the selector for the method you wish to override. </td></tr>
    <tr><td class="paramname">oldSelector</td><td>This is the selector that will be used for accessing the old implementation. This must have the same number of arguments as the original <code>selector</code>. </td></tr>
    <tr><td class="paramname">block</td><td>A block containing our new implementation. This block must start with an argument for the current object (the equivilant of the <code>self</code> argument&ndash;note that we do not need to include the <code>_cmd</code> argument). Next, we need to match all the method's arguments exactly. If you do not, it could cause the applicaiton to crash at runtime. Finally, the block needs to return the same type of data as the original method.</td></tr>
  </table>
  </dd>
</dl>
<p>This method starts by creating an alias of the specified method using the <code>oldSelector</code> argument. Then it replaces the method's current <code>IMP</code> with a new <code>IMP</code> created from the provided block. This leaves us with two, unique methods: <code>selector</code> points to our new implementation while <code>oldSelector</code> points to the old.</p>
<p>Our implementation block must return the same data type as the original implementation. It must also take a number of arguments equal to the original + 1 (for <code>_self</code>).</p>
<p>Examples: Method with no arguments: <code>[[Person class] FMS_overrideInstanceMethod:@selector(firstName) oldSelector:@selector(oldFirstName) implementationBlock:^(Person *_self){return [[_self oldFirstName] lowercaseString];}];</code></p>
<p>Method with one argument: <code>[[Person class] FMS_overrideInstanceMethod:@selector(setFirstName:) oldSelector:@selector(oldSetFirstName:) implementationBlock:^(Person *_self, NSString *name){ [_self oldSetFirstName:[name lowercaseString]];}];</code></p>
<p>Note: You must take care when replacing methods from class clusters. Classes like NSString, NSArray or NSDate declare a public, abstract class&ndash;but then provide private subclasses when instantiated. If you replace the abstract class (e.g. <code>[NSString FMS_replaceInstanceMethod:...</code>) your new method will probably be overridden by the concrete subclass, and will never be called. You must call <code>FMS_replaceInstanceMethod</code> on the subclass itself (e.g. `[[myString class] FMS_aliasInstanceMethod...). To make things even more difficult, different instances from the same class cluster may have different concrete subclasses. Bottom line, it's probably best to avoid replacing methods on class clusters. Alternatively, dynamically subclass the instance before creating the alias to limit the change to just that instance.</p>
<p>Note: Replacing methods may also cause unexpected results with KVO. Remember, if you are observing a keypath that corresponds to the method you have replaced, your new method will still trigger KVO notifications&ndash;even if you end up not changing the underlying values.</p>
<p>Note: There may be a few odd edge cases where the original method checks the _cmd hidden before determining its behavior. In these cases, the old implementation will use <code>oldSelector</code> for their _cmd value. So, they may no longer function properly. This should be rare, however. </p>

</div>
</div>
<a class="anchor" id="ada43393ead6d6976de66fd0df1211e3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) FMS_replaceClassMethod: </td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>methodSelector</em></td>
        </tr>
        <tr>
          <td class="paramkey">withImplementationBlock:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the specified class method with the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodSelector</td><td>The selector for the class method we wish to replace. </td></tr>
    <tr><td class="paramname">block</td><td>A block containing our new implementation. This block must start with an argument for the current class (the equivilant of the <code>self</code> argument in other class methods&ndash;note that we do not need to include the <code>_cmd</code> argument). Next, we need to match all the class method's arguments exactly. If you do not, it could cause the applicaiton to crash at runtime. Finally, the block needs to return the same type of data as the original method.</td></tr>
  </table>
  </dd>
</dl>
<p>This method replaces the specified class method's current <code>IMP</code> with a new <code>IMP</code> created from the provided block. Our block must return the same data type as the original implementation. It must also take a number of arguments equal to the original + 1 (for <code>_self</code>).</p>
<p>Examples: Method with 3 arguments: <code>[[Person class] FMS_replaceClassMethod:@selector(personWithFirstName:lastName:age:) withImplementationBlock:^(id _self, NSString *firstName, NSString *lastName, NSUInteger age){return nil;}];</code> </p>

</div>
</div>
<a class="anchor" id="ac4c9e082d74e163f82d2cd429f735a89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) FMS_replaceInstanceMethod: </td>
          <td></td>
          <td class="paramtype">(SEL)&#160;</td>
          <td class="paramname"><em>methodSelector</em></td>
        </tr>
        <tr>
          <td class="paramkey">withImplementationBlock:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the specified method with the given block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodSelector</td><td>The selector for the method we wish to replace. </td></tr>
    <tr><td class="paramname">block</td><td>A block containing our new implementation. This block must start with an argument for the current object (the equivilant of the <code>self</code> argument&ndash;note that we do not need to include the <code>_cmd</code> argument). Next, we need to match all the method's arguments exactly. If you do not, it could cause the applicaiton to crash at runtime. Finally, the block needs to return the same type of data as the original method.</td></tr>
  </table>
  </dd>
</dl>
<p>This method replaces the specified method's current <code>IMP</code> with a new <code>IMP</code> created from the provided block. Our block must return the same data type as the original implementation. It must also take a number of arguments equal to the original + 1 (for <code>_self</code>).</p>
<p>Examples: Method with no arguments: <code>[[Person class] FMS_replaceInstanceMethod:@selector(firstName) withImplementationBlock:^(Person *_self){return @"Bob";}];</code></p>
<p>Method with one argument: <code>[[Person class] FMS_replaceInstanceMethod:@selector(setFirstName:) withImplementationBlock:^(Person *_self, NSString *name){ // do something with the name here -- no need to return anything.}];</code></p>
<p>Note: replacing a method that the class relies on internally may cause unexpected results. Strongly consider using `FMS_OverrideInsanceMethod:oldSelector:implementationBlock: and calling the original method either before or after your modified code.</p>
<p>Note: You must take care when replacing methods from class clusters. Classes like NSString, NSArray or NSDate declare a public, abstract class&ndash;but then provide private subclasses when instantiated. If you replace the abstract class (e.g. <code>[NSString FMS_replaceInstanceMethod:...</code>) your new method will probably be overridden by the concrete subclass, and will never be called. You must call <code>FMS_replaceInstanceMethod</code> on the subclass itself (e.g. `[[myString class] FMS_aliasInstanceMethod...). To make things even more difficult, different instances from the same class cluster may have different concrete subclasses. Bottom line, it's probably best to avoid replacing methods on class clusters. Alternatively, dynamically subclass the instance before creating the alias to limit the change to just that instance.</p>
<p>Note: Replacing methods may also cause unexpected results with KVO. Remember, if you are observing a keypath that corresponds to the method you have replaced, your new method will still trigger KVO notifications&ndash;even if you end up not changing the underlying values. </p>

</div>
</div>
<hr/>The documentation for this category was generated from the following files:<ul>
<li>FMSSwizzler/<a class="el" href="_n_s_object_09_f_m_s_swizzler_8h_source.html">NSObject+FMSSwizzler.h</a></li>
<li>FMSSwizzler/NSObject+FMSSwizzler.m</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 10 2012 22:19:55 for FMSSwizzler by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
